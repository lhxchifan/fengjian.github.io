<!DOCTYPE html>
<html lang="zh-cmn-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>风间</title>
  
  
  
  <!--link rel="stylesheet" href="//cdn.jsdelivr.net/highlight.js/9.10.0/styles/github-gist.min.css"-->
  <link rel="stylesheet" href="//cdn.jsdelivr.net/highlight.js/9.10.0/styles/github-gist.min.css">
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
<div class="Shell">
    <aside class="SideBar">
    <section class="avatar" style="background-image: url()">
        <div class="av-pic" style="background-image: url()">
        </div>
    </section>
    <section class="menu">
        <div>风间</div>
        
        <ul>
          
            <a href="/" class="Btn">
              <li>Home</li>
            </a>  
          
            <a href="/archives/" class="Btn">
              <li>Archive</li>
            </a>  
          
        </ul>
    </section>
    <section class="media">
        
    </section>
</aside>

    <div class="container">
        <div data-pager-shell>
            <ul class="Index">
  
  
    <li>
      <article class="ListView">
    <header class="title">
      
      <div class="ListMeta">
  <time datetime="2018-11-01T03:44:45.458Z" itemprop="datePublished">
    2018-11-01
  </time>
  
  
</div>

    </header>
    <div>
      
        <h1 id="MarkOopDesc"><a href="#MarkOopDesc" class="headerlink" title="MarkOopDesc"></a>MarkOopDesc</h1><hr>
<p>tags:</p>
<ul>
<li>java</li>
<li>hotspot jvm</li>
</ul>
<p>categories:</p>
<ul>
<li>hotspot jvm</li>
</ul>
<h3 id="怪异的用法"><a href="#怪异的用法" class="headerlink" title="怪异的用法"></a>怪异的用法</h3><blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="class"><span class="keyword">class</span> <span class="title">markOopDesc</span>:</span> <span class="keyword">public</span> oopDesc &#123;</span><br><span class="line">&gt;  <span class="keyword">private</span>:</span><br><span class="line">&gt;   <span class="comment">// Conversion</span></span><br><span class="line">&gt;   <span class="keyword">uintptr_t</span> value() <span class="keyword">const</span> &#123; <span class="keyword">return</span> (<span class="keyword">uintptr_t</span>) <span class="keyword">this</span>; &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p><code>markOop</code> 实际上是用它的指针来存实际的bitfields，非常怪异</p>
</blockquote>
<h3 id="协议定义"><a href="#协议定义" class="headerlink" title="协议定义"></a>协议定义</h3><blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment">// Bit-format of an object header (most significant first, big endian layout below):</span></span><br><span class="line">&gt; <span class="comment">//</span></span><br><span class="line">&gt; <span class="comment">//  32 bits:</span></span><br><span class="line">&gt; <span class="comment">//  --------</span></span><br><span class="line">&gt; <span class="comment">//             hash:25 ------------&gt;| age:4    biased_lock:1 lock:2 (normal object)</span></span><br><span class="line">&gt; <span class="comment">//             JavaThread*:23 epoch:2 age:4    biased_lock:1 lock:2 (biased object)</span></span><br><span class="line">&gt; <span class="comment">//             size:32 ------------------------------------------&gt;| (CMS free block)</span></span><br><span class="line">&gt; <span class="comment">//             PromotedObject*:29 ----------&gt;| promo_bits:3 -----&gt;| (CMS promoted object)</span></span><br><span class="line">&gt; <span class="comment">//</span></span><br><span class="line">&gt; <span class="comment">//  64 bits:</span></span><br><span class="line">&gt; <span class="comment">//  --------</span></span><br><span class="line">&gt; <span class="comment">//  unused:25 hash:31 --&gt;| unused:1   age:4    biased_lock:1 lock:2 (normal object)</span></span><br><span class="line">&gt; <span class="comment">//  JavaThread*:54 epoch:2 unused:1   age:4    biased_lock:1 lock:2 (biased object)</span></span><br><span class="line">&gt; <span class="comment">//  PromotedObject*:61 ---------------------&gt;| promo_bits:3 -----&gt;| (CMS promoted object)</span></span><br><span class="line">&gt; <span class="comment">//  size:64 -----------------------------------------------------&gt;| (CMS free block)</span></span><br><span class="line">&gt; <span class="comment">//</span></span><br><span class="line">&gt; <span class="comment">//  unused:25 hash:31 --&gt;| cms_free:1 age:4    biased_lock:1 lock:2 (COOPs &amp;&amp; normal object)</span></span><br><span class="line">&gt; <span class="comment">//  JavaThread*:54 epoch:2 cms_free:1 age:4    biased_lock:1 lock:2 (COOPs &amp;&amp; biased object)</span></span><br><span class="line">&gt; <span class="comment">//  narrowOop:32 unused:24 cms_free:1 unused:4 promo_bits:3 -----&gt;| (COOPs &amp;&amp; CMS promoted object)</span></span><br><span class="line">&gt; <span class="comment">//  unused:21 size:35 --&gt;| cms_free:1 unused:7 ------------------&gt;| (COOPs &amp;&amp; CMS free block)</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h3><blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment">//    [JavaThread* | epoch | age | 1 | 01]       lock is biased toward given thread</span></span><br><span class="line">&gt; <span class="comment">//    [0           | epoch | age | 1 | 01]       lock is anonymously biased</span></span><br><span class="line">&gt; <span class="comment">//</span></span><br><span class="line">&gt; <span class="comment">//  - the two lock bits are used to describe three states: locked/unlocked and monitor.</span></span><br><span class="line">&gt; <span class="comment">//</span></span><br><span class="line">&gt; <span class="comment">//    [ptr             | 00]  locked             ptr points to real header on stack</span></span><br><span class="line">&gt; <span class="comment">//    [header      | 0 | 01]  unlocked           regular object header</span></span><br><span class="line">&gt; <span class="comment">//    [ptr             | 10]  monitor            inflated lock (header is wapped out)</span></span><br><span class="line">&gt; <span class="comment">//    [ptr             | 11]  marked             used by markSweep to mark an object</span></span><br><span class="line">&gt; <span class="comment">//                                               not valid at any other time</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p><img src="/Users/liuhongxuan/notes/source/_posts/markoop.png" alt="markoop"></p>
</blockquote>

      
    </div>
</article>

    </li>
  
    <li>
      <article class="ListView">
    <header class="title">
      
      <div class="ListMeta">
  <time datetime="2018-11-01T03:36:07.283Z" itemprop="datePublished">
    2018-11-01
  </time>
  
  
</div>

    </header>
    <div>
      
        <h1 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h1><hr>
<p>tags:</p>
<ul>
<li>hotspot jvm</li>
<li>lock</li>
<li>concurrent</li>
</ul>
<p>categories:</p>
<ul>
<li>hotspot jvm</li>
</ul>
<h3 id="procedure"><a href="#procedure" class="headerlink" title="procedure"></a>procedure</h3><p><img src="/Users/liuhongxuan/notes/source/_posts/javalock.png" alt="javalock"></p>
<h3 id="bytecodeInterpreter"><a href="#bytecodeInterpreter" class="headerlink" title="bytecodeInterpreter"></a>bytecodeInterpreter</h3><blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&gt; </span><br><span class="line">&gt; CASE(_monitorenter): &#123;</span><br><span class="line">&gt;         oop lockee = STACK_OBJECT(<span class="number">-1</span>);</span><br><span class="line">&gt;         <span class="comment">// derefing's lockee ought to provoke implicit null check</span></span><br><span class="line">&gt;         CHECK_NULL(lockee);</span><br><span class="line">&gt;         <span class="comment">// find a free monitor or one already allocated for this object</span></span><br><span class="line">&gt;         <span class="comment">// if we find a matching object then we need a new monitor</span></span><br><span class="line">&gt;         <span class="comment">// since this is recursive enter</span></span><br><span class="line">&gt;         BasicObjectLock* limit = istate-&gt;monitor_base();</span><br><span class="line">&gt;         BasicObjectLock* most_recent = (BasicObjectLock*) istate-&gt;stack_base();</span><br><span class="line">&gt;         BasicObjectLock* entry = <span class="literal">NULL</span>;</span><br><span class="line">&gt;         <span class="keyword">while</span> (most_recent != limit ) &#123;</span><br><span class="line">&gt;           <span class="keyword">if</span> (most_recent-&gt;obj() == <span class="literal">NULL</span>) entry = most_recent;</span><br><span class="line">&gt;           <span class="keyword">else</span> <span class="keyword">if</span> (most_recent-&gt;obj() == lockee) <span class="keyword">break</span>;</span><br><span class="line">&gt;           most_recent++;</span><br><span class="line">&gt;         &#125;</span><br><span class="line">&gt;         <span class="keyword">if</span> (entry != <span class="literal">NULL</span>) &#123;</span><br><span class="line">&gt;           entry-&gt;set_obj(lockee);</span><br><span class="line">&gt;           markOop displaced = lockee-&gt;mark()-&gt;set_unlocked();</span><br><span class="line">&gt;           entry-&gt;lock()-&gt;set_displaced_header(displaced);</span><br><span class="line">&gt;           <span class="keyword">if</span> (Atomic::cmpxchg_ptr(entry, lockee-&gt;mark_addr(), displaced) != displaced) &#123;</span><br><span class="line">&gt;             <span class="comment">// Is it simple recursive case?</span></span><br><span class="line">&gt;             <span class="keyword">if</span> (THREAD-&gt;is_lock_owned((address) displaced-&gt;clear_lock_bits())) &#123;</span><br><span class="line">&gt;               entry-&gt;lock()-&gt;set_displaced_header(<span class="literal">NULL</span>);</span><br><span class="line">&gt;             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">&gt;               CALL_VM(InterpreterRuntime::monitorenter(THREAD, entry), handle_exception);</span><br><span class="line">&gt;             &#125;</span><br><span class="line">&gt;           &#125;</span><br><span class="line">&gt;           UPDATE_PC_AND_TOS_AND_CONTINUE(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">&gt;         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">&gt;           istate-&gt;set_msg(more_monitors);</span><br><span class="line">&gt;           UPDATE_PC_AND_RETURN(<span class="number">0</span>); <span class="comment">// Re-execute</span></span><br><span class="line">&gt;         &#125;</span><br><span class="line">&gt;       &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<blockquote>
<ol>
<li>找到已经分配的或者free的monitor</li>
<li>cas 给object的markword赋值</li>
<li>cas失败，如果是线程重入，算成功</li>
<li>call InterpreterRuntime::monitorenter</li>
</ol>
</blockquote>
</blockquote>
<h3 id="InterpreterRuntime-monitorenter"><a href="#InterpreterRuntime-monitorenter" class="headerlink" title="InterpreterRuntime::monitorenter"></a>InterpreterRuntime::monitorenter</h3><blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&gt; IRT_ENTRY_NO_ASYNC(<span class="keyword">void</span>, InterpreterRuntime::monitorenter(JavaThread* thread, BasicObjectLock* elem))</span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">ifdef</span> ASSERT</span></span><br><span class="line">&gt;   thread-&gt;last_frame().interpreter_frame_verify_monitor(elem);</span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&gt;   <span class="keyword">if</span> (PrintBiasedLockingStatistics) &#123;</span><br><span class="line">&gt;     Atomic::inc(BiasedLocking::slow_path_entry_count_addr());</span><br><span class="line">&gt;   &#125;</span><br><span class="line">&gt;   <span class="function">Handle <span class="title">h_obj</span><span class="params">(thread, elem-&gt;obj())</span></span>;</span><br><span class="line">&gt;   assert(Universe::heap()-&gt;is_in_reserved_or_null(h_obj()),</span><br><span class="line">&gt;          <span class="string">"must be NULL or an object"</span>);</span><br><span class="line">&gt;   <span class="keyword">if</span> (UseBiasedLocking) &#123;</span><br><span class="line">&gt;     <span class="comment">// Retry fast entry if bias is revoked to avoid unnecessary inflation</span></span><br><span class="line">&gt;     ObjectSynchronizer::fast_enter(h_obj, elem-&gt;lock(), <span class="literal">true</span>, CHECK);</span><br><span class="line">&gt;   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">&gt;     ObjectSynchronizer::slow_enter(h_obj, elem-&gt;lock(), CHECK);</span><br><span class="line">&gt;   &#125;</span><br><span class="line">&gt;   assert(Universe::heap()-&gt;is_in_reserved_or_null(elem-&gt;obj()),</span><br><span class="line">&gt;          <span class="string">"must be NULL or an object"</span>);</span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">ifdef</span> ASSERT</span></span><br><span class="line">&gt;   thread-&gt;last_frame().interpreter_frame_verify_monitor(elem);</span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&gt; IRT_END</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<h4 id="summarize"><a href="#summarize" class="headerlink" title="summarize"></a>summarize</h4><ol>
<li>如果用偏向锁，进如fast_enter</li>
<li>否则进如slow_enter</li>
<li><strong>偏向锁的逻辑懒得看了</strong>，直接看slow_enter</li>
</ol>
</blockquote>
<h3 id="slow-enter"><a href="#slow-enter" class="headerlink" title="slow_enter"></a>slow_enter</h3><blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment">// -----------------------------------------------------------------------------</span></span><br><span class="line">&gt; <span class="comment">// Interpreter/Compiler Slow Case</span></span><br><span class="line">&gt; <span class="comment">// This routine is used to handle interpreter/compiler slow case</span></span><br><span class="line">&gt; <span class="comment">// We don't need to use fast path here, because it must have been</span></span><br><span class="line">&gt; <span class="comment">// failed in the interpreter/compiler code.</span></span><br><span class="line">&gt; <span class="keyword">void</span> ObjectSynchronizer::slow_enter(Handle obj, BasicLock* lock, TRAPS) &#123;</span><br><span class="line">&gt;   markOop mark = obj-&gt;mark();</span><br><span class="line">&gt;   assert(!mark-&gt;has_bias_pattern(), <span class="string">"should not see bias pattern here"</span>);</span><br><span class="line">&gt; </span><br><span class="line">&gt;   <span class="keyword">if</span> (mark-&gt;is_neutral()) &#123;</span><br><span class="line">&gt;     <span class="comment">// Anticipate successful CAS -- the ST of the displaced mark must</span></span><br><span class="line">&gt;     <span class="comment">// be visible &lt;= the ST performed by the CAS.</span></span><br><span class="line">&gt;     lock-&gt;set_displaced_header(mark);</span><br><span class="line">&gt;     <span class="keyword">if</span> (mark == (markOop) Atomic::cmpxchg_ptr(lock, obj()-&gt;mark_addr(), mark)) &#123;</span><br><span class="line">&gt;       TEVENT (slow_enter: release stacklock) ;</span><br><span class="line">&gt;       <span class="keyword">return</span> ;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt;     <span class="comment">// Fall through to inflate() ...</span></span><br><span class="line">&gt;   &#125; <span class="keyword">else</span></span><br><span class="line">&gt;   <span class="keyword">if</span> (mark-&gt;has_locker() &amp;&amp; THREAD-&gt;is_lock_owned((address)mark-&gt;locker())) &#123;</span><br><span class="line">&gt;     assert(lock != mark-&gt;locker(), <span class="string">"must not re-lock the same lock"</span>);</span><br><span class="line">&gt;     assert(lock != (BasicLock*)obj-&gt;mark(), <span class="string">"don't relock with same BasicLock"</span>);</span><br><span class="line">&gt;     lock-&gt;set_displaced_header(<span class="literal">NULL</span>);</span><br><span class="line">&gt;     <span class="keyword">return</span>;</span><br><span class="line">&gt;   &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">&gt;   <span class="comment">// The following optimization isn't particularly useful.</span></span><br><span class="line">&gt;   <span class="keyword">if</span> (mark-&gt;has_monitor() &amp;&amp; mark-&gt;monitor()-&gt;is_entered(THREAD)) &#123;</span><br><span class="line">&gt;     lock-&gt;set_displaced_header (<span class="literal">NULL</span>) ;</span><br><span class="line">&gt;     <span class="keyword">return</span> ;</span><br><span class="line">&gt;   &#125;</span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&gt; </span><br><span class="line">&gt;   <span class="comment">// The object header will never be displaced to this lock,</span></span><br><span class="line">&gt;   <span class="comment">// so it does not matter what the value is, except that it</span></span><br><span class="line">&gt;   <span class="comment">// must be non-zero to avoid looking like a re-entrant lock,</span></span><br><span class="line">&gt;   <span class="comment">// and must not look locked either.</span></span><br><span class="line">&gt;   lock-&gt;set_displaced_header(markOopDesc::unused_mark());</span><br><span class="line">&gt;   ObjectSynchronizer::inflate(THREAD, obj())-&gt;enter(THREAD);</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<ol>
<li>如果当前没有上锁，即取markword后三位为001，并且cas成功，就返回(目测是轻量级锁的逻辑)</li>
<li>mark-&gt;has_locker()判断后两位是不是轻量级锁，即后两位是不是00，如果是，并且是当前线程，返回</li>
<li>inflate and enter</li>
</ol>
</blockquote>
<h3 id="enter"><a href="#enter" class="headerlink" title="enter"></a>enter</h3><blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">void</span> ATTR ObjectMonitor::enter(TRAPS) &#123;</span><br><span class="line">&gt;   <span class="comment">// The following code is ordered to check the most common cases first</span></span><br><span class="line">&gt;   <span class="comment">// and to reduce RTS-&gt;RTO cache line upgrades on SPARC and IA32 processors.</span></span><br><span class="line">&gt;   Thread * <span class="keyword">const</span> Self = THREAD ;</span><br><span class="line">&gt;   <span class="keyword">void</span> * cur ;</span><br><span class="line">&gt; </span><br><span class="line">&gt;   cur = Atomic::cmpxchg_ptr (Self, &amp;_owner, <span class="literal">NULL</span>) ;</span><br><span class="line">&gt;   <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) &#123;</span><br><span class="line">&gt;      <span class="comment">// Either ASSERT _recursions == 0 or explicitly set _recursions = 0.</span></span><br><span class="line">&gt;      assert (_recursions == <span class="number">0</span>   , <span class="string">"invariant"</span>) ;</span><br><span class="line">&gt;      assert (_owner      == Self, <span class="string">"invariant"</span>) ;</span><br><span class="line">&gt;      <span class="comment">// CONSIDER: set or assert OwnerIsThread == 1</span></span><br><span class="line">&gt;      <span class="keyword">return</span> ;</span><br><span class="line">&gt;   &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt;   <span class="keyword">if</span> (cur == Self) &#123;</span><br><span class="line">&gt;      <span class="comment">// TODO-<span class="doctag">FIXME:</span> check for integer overflow!  BUGID 6557169.</span></span><br><span class="line">&gt;      _recursions ++ ;</span><br><span class="line">&gt;      <span class="keyword">return</span> ;</span><br><span class="line">&gt;   &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt;   <span class="keyword">if</span> (Self-&gt;is_lock_owned ((address)cur)) &#123;</span><br><span class="line">&gt;     assert (_recursions == <span class="number">0</span>, <span class="string">"internal state error"</span>);</span><br><span class="line">&gt;     _recursions = <span class="number">1</span> ;</span><br><span class="line">&gt;     <span class="comment">// Commute owner from a thread-specific on-stack BasicLockObject address to</span></span><br><span class="line">&gt;     <span class="comment">// a full-fledged "Thread *".</span></span><br><span class="line">&gt;     _owner = Self ;</span><br><span class="line">&gt;     OwnerIsThread = <span class="number">1</span> ;</span><br><span class="line">&gt;     <span class="keyword">return</span> ;</span><br><span class="line">&gt;   &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt;   <span class="comment">// We've encountered genuine contention.</span></span><br><span class="line">&gt;   assert (Self-&gt;_Stalled == <span class="number">0</span>, <span class="string">"invariant"</span>) ;</span><br><span class="line">&gt;   Self-&gt;_Stalled = <span class="keyword">intptr_t</span>(<span class="keyword">this</span>) ;</span><br><span class="line">&gt; </span><br><span class="line">&gt;   <span class="comment">// Try one round of spinning *before* enqueueing Self</span></span><br><span class="line">&gt;   <span class="comment">// and before going through the awkward and expensive state</span></span><br><span class="line">&gt;   <span class="comment">// transitions.  The following spin is strictly optional ...</span></span><br><span class="line">&gt;   <span class="comment">// Note that if we acquire the monitor from an initial spin</span></span><br><span class="line">&gt;   <span class="comment">// we forgo posting JVMTI events and firing DTRACE probes.</span></span><br><span class="line">&gt;   <span class="keyword">if</span> (Knob_SpinEarly &amp;&amp; TrySpin (Self) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">&gt;      assert (_owner == Self      , <span class="string">"invariant"</span>) ;</span><br><span class="line">&gt;      assert (_recursions == <span class="number">0</span>    , <span class="string">"invariant"</span>) ;</span><br><span class="line">&gt;      assert (((oop)(object()))-&gt;mark() == markOopDesc::encode(<span class="keyword">this</span>), <span class="string">"invariant"</span>) ;</span><br><span class="line">&gt;      Self-&gt;_Stalled = <span class="number">0</span> ;</span><br><span class="line">&gt;      <span class="keyword">return</span> ;</span><br><span class="line">&gt;   &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt;   assert (_owner != Self          , <span class="string">"invariant"</span>) ;</span><br><span class="line">&gt;   assert (_succ  != Self          , <span class="string">"invariant"</span>) ;</span><br><span class="line">&gt;   assert (Self-&gt;is_Java_thread()  , <span class="string">"invariant"</span>) ;</span><br><span class="line">&gt;   JavaThread * jt = (JavaThread *) Self ;</span><br><span class="line">&gt;   assert (!SafepointSynchronize::is_at_safepoint(), <span class="string">"invariant"</span>) ;</span><br><span class="line">&gt;   assert (jt-&gt;thread_state() != _thread_blocked   , <span class="string">"invariant"</span>) ;</span><br><span class="line">&gt;   assert (<span class="keyword">this</span>-&gt;object() != <span class="literal">NULL</span>  , <span class="string">"invariant"</span>) ;</span><br><span class="line">&gt;   assert (_count &gt;= <span class="number">0</span>, <span class="string">"invariant"</span>) ;</span><br><span class="line">&gt; </span><br><span class="line">&gt;   <span class="comment">// Prevent deflation at STW-time.  See deflate_idle_monitors() and is_busy().</span></span><br><span class="line">&gt;   <span class="comment">// Ensure the object-monitor relationship remains stable while there's contention.</span></span><br><span class="line">&gt;   Atomic::inc_ptr(&amp;_count);</span><br><span class="line">&gt; </span><br><span class="line">&gt;   EventJavaMonitorEnter event;</span><br><span class="line">&gt; </span><br><span class="line">&gt;   &#123; <span class="comment">// Change java thread status to indicate blocked on monitor enter.</span></span><br><span class="line">&gt;     <span class="function">JavaThreadBlockedOnMonitorEnterState <span class="title">jtbmes</span><span class="params">(jt, <span class="keyword">this</span>)</span></span>;</span><br><span class="line">&gt; </span><br><span class="line">&gt;     DTRACE_MONITOR_PROBE(contended__enter, <span class="keyword">this</span>, object(), jt);</span><br><span class="line">&gt;     <span class="keyword">if</span> (JvmtiExport::should_post_monitor_contended_enter()) &#123;</span><br><span class="line">&gt;       JvmtiExport::post_monitor_contended_enter(jt, <span class="keyword">this</span>);</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt;     <span class="function">OSThreadContendState <span class="title">osts</span><span class="params">(Self-&gt;osthread())</span></span>;</span><br><span class="line">&gt;     <span class="function">ThreadBlockInVM <span class="title">tbivm</span><span class="params">(jt)</span></span>;</span><br><span class="line">&gt; </span><br><span class="line">&gt;     Self-&gt;set_current_pending_monitor(<span class="keyword">this</span>);</span><br><span class="line">&gt; </span><br><span class="line">&gt;     <span class="comment">// TODO-<span class="doctag">FIXME:</span> change the following for(;;) loop to straight-line code.</span></span><br><span class="line">&gt;     <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">&gt;       jt-&gt;set_suspend_equivalent();</span><br><span class="line">&gt;       <span class="comment">// cleared by handle_special_suspend_equivalent_condition()</span></span><br><span class="line">&gt;       <span class="comment">// or java_suspend_self()</span></span><br><span class="line">&gt; </span><br><span class="line">&gt;       EnterI (THREAD) ;</span><br><span class="line">&gt; </span><br><span class="line">&gt;       <span class="keyword">if</span> (!ExitSuspendEquivalent(jt)) <span class="keyword">break</span> ;</span><br><span class="line">&gt; </span><br><span class="line">&gt;       <span class="comment">//</span></span><br><span class="line">&gt;       <span class="comment">// We have acquired the contended monitor, but while we were</span></span><br><span class="line">&gt;       <span class="comment">// waiting another thread suspended us. We don't want to enter</span></span><br><span class="line">&gt;       <span class="comment">// the monitor while suspended because that would surprise the</span></span><br><span class="line">&gt;       <span class="comment">// thread that suspended us.</span></span><br><span class="line">&gt;       <span class="comment">//</span></span><br><span class="line">&gt;           _recursions = <span class="number">0</span> ;</span><br><span class="line">&gt;       _succ = <span class="literal">NULL</span> ;</span><br><span class="line">&gt;       <span class="built_in">exit</span> (<span class="literal">false</span>, Self) ;</span><br><span class="line">&gt; </span><br><span class="line">&gt;       jt-&gt;java_suspend_self();</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt;     Self-&gt;set_current_pending_monitor(<span class="literal">NULL</span>);</span><br><span class="line">&gt;   &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt;   Atomic::dec_ptr(&amp;_count);</span><br><span class="line">&gt;   assert (_count &gt;= <span class="number">0</span>, <span class="string">"invariant"</span>) ;</span><br><span class="line">&gt;   Self-&gt;_Stalled = <span class="number">0</span> ;</span><br><span class="line">&gt; </span><br><span class="line">&gt;   <span class="comment">// Must either set _recursions = 0 or ASSERT _recursions == 0.</span></span><br><span class="line">&gt;   assert (_recursions == <span class="number">0</span>     , <span class="string">"invariant"</span>) ;</span><br><span class="line">&gt;   assert (_owner == Self       , <span class="string">"invariant"</span>) ;</span><br><span class="line">&gt;   assert (_succ  != Self       , <span class="string">"invariant"</span>) ;</span><br><span class="line">&gt;   assert (((oop)(object()))-&gt;mark() == markOopDesc::encode(<span class="keyword">this</span>), <span class="string">"invariant"</span>) ;</span><br><span class="line">&gt; </span><br><span class="line">&gt;   <span class="comment">// The thread -- now the owner -- is back in vm mode.</span></span><br><span class="line">&gt;   <span class="comment">// Report the glorious news via TI,DTrace and jvmstat.</span></span><br><span class="line">&gt;   <span class="comment">// The probe effect is non-trivial.  All the reportage occurs</span></span><br><span class="line">&gt;   <span class="comment">// while we hold the monitor, increasing the length of the critical</span></span><br><span class="line">&gt;   <span class="comment">// section.  Amdahl's parallel speedup law comes vividly into play.</span></span><br><span class="line">&gt;   <span class="comment">//</span></span><br><span class="line">&gt;   <span class="comment">// Another option might be to aggregate the events (thread local or</span></span><br><span class="line">&gt;   <span class="comment">// per-monitor aggregation) and defer reporting until a more opportune</span></span><br><span class="line">&gt;   <span class="comment">// time -- such as next time some thread encounters contention but has</span></span><br><span class="line">&gt;   <span class="comment">// yet to acquire the lock.  While spinning that thread could</span></span><br><span class="line">&gt;   <span class="comment">// spinning we could increment JVMStat counters, etc.</span></span><br><span class="line">&gt; </span><br><span class="line">&gt;   DTRACE_MONITOR_PROBE(contended__entered, <span class="keyword">this</span>, object(), jt);</span><br><span class="line">&gt;   <span class="keyword">if</span> (JvmtiExport::should_post_monitor_contended_entered()) &#123;</span><br><span class="line">&gt;     JvmtiExport::post_monitor_contended_entered(jt, <span class="keyword">this</span>);</span><br><span class="line">&gt;   &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt;   <span class="keyword">if</span> (event.should_commit()) &#123;</span><br><span class="line">&gt;     event.set_klass(((oop)<span class="keyword">this</span>-&gt;object())-&gt;klass());</span><br><span class="line">&gt;     event.set_previousOwner((TYPE_JAVALANGTHREAD)_previous_owner_tid);</span><br><span class="line">&gt;     event.set_address((TYPE_ADDRESS)(<span class="keyword">uintptr_t</span>)(<span class="keyword">this</span>-&gt;object_addr()));</span><br><span class="line">&gt;     event.commit();</span><br><span class="line">&gt;   &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt;   <span class="keyword">if</span> (ObjectMonitor::_sync_ContendedLockAttempts != <span class="literal">NULL</span>) &#123;</span><br><span class="line">&gt;      ObjectMonitor::_sync_ContendedLockAttempts-&gt;inc() ;</span><br><span class="line">&gt;   &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<ol>
<li>cas设置ObjectMonitor的owner为当前线程，如果失败了则返回，说明objectmonitor已经有owner了</li>
<li>如果owner本来就是自己，<code>_recursions ++</code> ，返回</li>
<li>如果之前的BasicLockObject是一个在当前线程栈上的锁？？？，</li>
<li>设置当前线程的_Stalled为这个objectMonitor</li>
<li>先自旋一段时间，看能不能获取锁，能获取则返回</li>
<li>不能的话，设置当前线程的_current_pending_monitor</li>
<li>EnterI</li>
</ol>
</blockquote>
<h3 id="EnterI"><a href="#EnterI" class="headerlink" title="EnterI"></a>EnterI</h3><blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">void</span> ATTR ObjectMonitor::EnterI (TRAPS) &#123;</span><br><span class="line">&gt;     Thread * Self = THREAD ;</span><br><span class="line">&gt;     assert (Self-&gt;is_Java_thread(), <span class="string">"invariant"</span>) ;</span><br><span class="line">&gt;     assert (((JavaThread *) Self)-&gt;thread_state() == _thread_blocked   , <span class="string">"invariant"</span>) ;</span><br><span class="line">&gt; </span><br><span class="line">&gt;     <span class="comment">// Try the lock - TATAS</span></span><br><span class="line">&gt;     <span class="keyword">if</span> (TryLock (Self) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">&gt;         assert (_succ != Self              , <span class="string">"invariant"</span>) ;</span><br><span class="line">&gt;         assert (_owner == Self             , <span class="string">"invariant"</span>) ;</span><br><span class="line">&gt;         assert (_Responsible != Self       , <span class="string">"invariant"</span>) ;</span><br><span class="line">&gt;         <span class="keyword">return</span> ;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt;     DeferredInitialize () ;</span><br><span class="line">&gt; </span><br><span class="line">&gt;     <span class="comment">// We try one round of spinning *before* enqueueing Self.</span></span><br><span class="line">&gt;     <span class="comment">//</span></span><br><span class="line">&gt;     <span class="comment">// If the _owner is ready but OFFPROC we could use a YieldTo()</span></span><br><span class="line">&gt;     <span class="comment">// operation to donate the remainder of this thread's quantum</span></span><br><span class="line">&gt;     <span class="comment">// to the owner.  This has subtle but beneficial affinity</span></span><br><span class="line">&gt;     <span class="comment">// effects.</span></span><br><span class="line">&gt; </span><br><span class="line">&gt;     <span class="keyword">if</span> (TrySpin (Self) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">&gt;         assert (_owner == Self        , <span class="string">"invariant"</span>) ;</span><br><span class="line">&gt;         assert (_succ != Self         , <span class="string">"invariant"</span>) ;</span><br><span class="line">&gt;         assert (_Responsible != Self  , <span class="string">"invariant"</span>) ;</span><br><span class="line">&gt;         <span class="keyword">return</span> ;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt;     <span class="comment">// The Spin failed -- Enqueue and park the thread ...</span></span><br><span class="line">&gt;     assert (_succ  != Self            , <span class="string">"invariant"</span>) ;</span><br><span class="line">&gt;     assert (_owner != Self            , <span class="string">"invariant"</span>) ;</span><br><span class="line">&gt;     assert (_Responsible != Self      , <span class="string">"invariant"</span>) ;</span><br><span class="line">&gt; </span><br><span class="line">&gt;     <span class="comment">// Enqueue "Self" on ObjectMonitor's _cxq.</span></span><br><span class="line">&gt;     <span class="comment">//</span></span><br><span class="line">&gt;     <span class="comment">// Node acts as a proxy for Self.</span></span><br><span class="line">&gt;     <span class="comment">// As an aside, if were to ever rewrite the synchronization code mostly</span></span><br><span class="line">&gt;     <span class="comment">// in Java, WaitNodes, ObjectMonitors, and Events would become 1st-class</span></span><br><span class="line">&gt;     <span class="comment">// Java objects.  This would avoid awkward lifecycle and liveness issues,</span></span><br><span class="line">&gt;     <span class="comment">// as well as eliminate a subset of ABA issues.</span></span><br><span class="line">&gt;     <span class="comment">// <span class="doctag">TODO:</span> eliminate ObjectWaiter and enqueue either Threads or Events.</span></span><br><span class="line">&gt;     <span class="comment">//</span></span><br><span class="line">&gt; </span><br><span class="line">&gt;     <span class="function">ObjectWaiter <span class="title">node</span><span class="params">(Self)</span> </span>;</span><br><span class="line">&gt;     Self-&gt;_ParkEvent-&gt;reset() ;</span><br><span class="line">&gt;     node._prev   = (ObjectWaiter *) <span class="number">0xBAD</span> ;</span><br><span class="line">&gt;     node.TState  = ObjectWaiter::TS_CXQ ;</span><br><span class="line">&gt; </span><br><span class="line">&gt;     <span class="comment">// Push "Self" onto the front of the _cxq.</span></span><br><span class="line">&gt;     <span class="comment">// Once on cxq/EntryList, Self stays on-queue until it acquires the lock.</span></span><br><span class="line">&gt;     <span class="comment">// Note that spinning tends to reduce the rate at which threads</span></span><br><span class="line">&gt;     <span class="comment">// enqueue and dequeue on EntryList|cxq.</span></span><br><span class="line">&gt;     ObjectWaiter * nxt ;</span><br><span class="line">&gt;     <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">&gt;         node._next = nxt = _cxq ;</span><br><span class="line">&gt;         <span class="keyword">if</span> (Atomic::cmpxchg_ptr (&amp;node, &amp;_cxq, nxt) == nxt) <span class="keyword">break</span> ;</span><br><span class="line">&gt; </span><br><span class="line">&gt;         <span class="comment">// Interference - the CAS failed because _cxq changed.  Just retry.</span></span><br><span class="line">&gt;         <span class="comment">// As an optional optimization we retry the lock.</span></span><br><span class="line">&gt;         <span class="keyword">if</span> (TryLock (Self) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">&gt;             assert (_succ != Self         , <span class="string">"invariant"</span>) ;</span><br><span class="line">&gt;             assert (_owner == Self        , <span class="string">"invariant"</span>) ;</span><br><span class="line">&gt;             assert (_Responsible != Self  , <span class="string">"invariant"</span>) ;</span><br><span class="line">&gt;             <span class="keyword">return</span> ;</span><br><span class="line">&gt;         &#125;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt;     <span class="comment">// Check for cxq|EntryList edge transition to non-null.  This indicates</span></span><br><span class="line">&gt;     <span class="comment">// the onset of contention.  While contention persists exiting threads</span></span><br><span class="line">&gt;     <span class="comment">// will use a ST:MEMBAR:LD 1-1 exit protocol.  When contention abates exit</span></span><br><span class="line">&gt;     <span class="comment">// operations revert to the faster 1-0 mode.  This enter operation may interleave</span></span><br><span class="line">&gt;     <span class="comment">// (race) a concurrent 1-0 exit operation, resulting in stranding, so we</span></span><br><span class="line">&gt;     <span class="comment">// arrange for one of the contending thread to use a timed park() operations</span></span><br><span class="line">&gt;     <span class="comment">// to detect and recover from the race.  (Stranding is form of progress failure</span></span><br><span class="line">&gt;     <span class="comment">// where the monitor is unlocked but all the contending threads remain parked).</span></span><br><span class="line">&gt;     <span class="comment">// That is, at least one of the contended threads will periodically poll _owner.</span></span><br><span class="line">&gt;     <span class="comment">// One of the contending threads will become the designated "Responsible" thread.</span></span><br><span class="line">&gt;     <span class="comment">// The Responsible thread uses a timed park instead of a normal indefinite park</span></span><br><span class="line">&gt;     <span class="comment">// operation -- it periodically wakes and checks for and recovers from potential</span></span><br><span class="line">&gt;     <span class="comment">// strandings admitted by 1-0 exit operations.   We need at most one Responsible</span></span><br><span class="line">&gt;     <span class="comment">// thread per-monitor at any given moment.  Only threads on cxq|EntryList may</span></span><br><span class="line">&gt;     <span class="comment">// be responsible for a monitor.</span></span><br><span class="line">&gt;     <span class="comment">//</span></span><br><span class="line">&gt;     <span class="comment">// Currently, one of the contended threads takes on the added role of "Responsible".</span></span><br><span class="line">&gt;     <span class="comment">// A viable alternative would be to use a dedicated "stranding checker" thread</span></span><br><span class="line">&gt;     <span class="comment">// that periodically iterated over all the threads (or active monitors) and unparked</span></span><br><span class="line">&gt;     <span class="comment">// successors where there was risk of stranding.  This would help eliminate the</span></span><br><span class="line">&gt;     <span class="comment">// timer scalability issues we see on some platforms as we'd only have one thread</span></span><br><span class="line">&gt;     <span class="comment">// -- the checker -- parked on a timer.</span></span><br><span class="line">&gt; </span><br><span class="line">&gt;     <span class="keyword">if</span> ((SyncFlags &amp; <span class="number">16</span>) == <span class="number">0</span> &amp;&amp; nxt == <span class="literal">NULL</span> &amp;&amp; _EntryList == <span class="literal">NULL</span>) &#123;</span><br><span class="line">&gt;         <span class="comment">// Try to assume the role of responsible thread for the monitor.</span></span><br><span class="line">&gt;         <span class="comment">// CONSIDER:  ST vs CAS vs &#123; if (Responsible==null) Responsible=Self &#125;</span></span><br><span class="line">&gt;         Atomic::cmpxchg_ptr (Self, &amp;_Responsible, <span class="literal">NULL</span>) ;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt;     <span class="comment">// The lock have been released while this thread was occupied queueing</span></span><br><span class="line">&gt;     <span class="comment">// itself onto _cxq.  To close the race and avoid "stranding" and</span></span><br><span class="line">&gt;     <span class="comment">// progress-liveness failure we must resample-retry _owner before parking.</span></span><br><span class="line">&gt;     <span class="comment">// Note the Dekker/Lamport duality: ST cxq; MEMBAR; LD Owner.</span></span><br><span class="line">&gt;     <span class="comment">// In this case the ST-MEMBAR is accomplished with CAS().</span></span><br><span class="line">&gt;     <span class="comment">//</span></span><br><span class="line">&gt;     <span class="comment">// <span class="doctag">TODO:</span> Defer all thread state transitions until park-time.</span></span><br><span class="line">&gt;     <span class="comment">// Since state transitions are heavy and inefficient we'd like</span></span><br><span class="line">&gt;     <span class="comment">// to defer the state transitions until absolutely necessary,</span></span><br><span class="line">&gt;     <span class="comment">// and in doing so avoid some transitions ...</span></span><br><span class="line">&gt; </span><br><span class="line">&gt;     TEVENT (Inflated enter - Contention) ;</span><br><span class="line">&gt;     <span class="keyword">int</span> nWakeups = <span class="number">0</span> ;</span><br><span class="line">&gt;     <span class="keyword">int</span> RecheckInterval = <span class="number">1</span> ;</span><br><span class="line">&gt; </span><br><span class="line">&gt;     <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">&gt; </span><br><span class="line">&gt;         <span class="keyword">if</span> (TryLock (Self) &gt; <span class="number">0</span>) <span class="keyword">break</span> ;</span><br><span class="line">&gt;         assert (_owner != Self, <span class="string">"invariant"</span>) ;</span><br><span class="line">&gt; </span><br><span class="line">&gt;         <span class="keyword">if</span> ((SyncFlags &amp; <span class="number">2</span>) &amp;&amp; _Responsible == <span class="literal">NULL</span>) &#123;</span><br><span class="line">&gt;            Atomic::cmpxchg_ptr (Self, &amp;_Responsible, <span class="literal">NULL</span>) ;</span><br><span class="line">&gt;         &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt;         <span class="comment">// park self</span></span><br><span class="line">&gt;         <span class="keyword">if</span> (_Responsible == Self || (SyncFlags &amp; <span class="number">1</span>)) &#123;</span><br><span class="line">&gt;             TEVENT (Inflated enter - park TIMED) ;</span><br><span class="line">&gt;             Self-&gt;_ParkEvent-&gt;park ((jlong) RecheckInterval) ;</span><br><span class="line">&gt;             <span class="comment">// Increase the RecheckInterval, but clamp the value.</span></span><br><span class="line">&gt;             RecheckInterval *= <span class="number">8</span> ;</span><br><span class="line">&gt;             <span class="keyword">if</span> (RecheckInterval &gt; <span class="number">1000</span>) RecheckInterval = <span class="number">1000</span> ;</span><br><span class="line">&gt;         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">&gt;             TEVENT (Inflated enter - park UNTIMED) ;</span><br><span class="line">&gt;             Self-&gt;_ParkEvent-&gt;park() ;</span><br><span class="line">&gt;         &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt;         <span class="keyword">if</span> (TryLock(Self) &gt; <span class="number">0</span>) <span class="keyword">break</span> ;</span><br><span class="line">&gt; </span><br><span class="line">&gt;         <span class="comment">// The lock is still contested.</span></span><br><span class="line">&gt;         <span class="comment">// Keep a tally of the # of futile wakeups.</span></span><br><span class="line">&gt;         <span class="comment">// Note that the counter is not protected by a lock or updated by atomics.</span></span><br><span class="line">&gt;         <span class="comment">// That is by design - we trade "lossy" counters which are exposed to</span></span><br><span class="line">&gt;         <span class="comment">// races during updates for a lower probe effect.</span></span><br><span class="line">&gt;         TEVENT (Inflated enter - Futile wakeup) ;</span><br><span class="line">&gt;         <span class="keyword">if</span> (ObjectMonitor::_sync_FutileWakeups != <span class="literal">NULL</span>) &#123;</span><br><span class="line">&gt;            ObjectMonitor::_sync_FutileWakeups-&gt;inc() ;</span><br><span class="line">&gt;         &#125;</span><br><span class="line">&gt;         ++ nWakeups ;</span><br><span class="line">&gt; </span><br><span class="line">&gt;         <span class="comment">// Assuming this is not a spurious wakeup we'll normally find _succ == Self.</span></span><br><span class="line">&gt;         <span class="comment">// We can defer clearing _succ until after the spin completes</span></span><br><span class="line">&gt;         <span class="comment">// TrySpin() must tolerate being called with _succ == Self.</span></span><br><span class="line">&gt;         <span class="comment">// Try yet another round of adaptive spinning.</span></span><br><span class="line">&gt;         <span class="keyword">if</span> ((Knob_SpinAfterFutile &amp; <span class="number">1</span>) &amp;&amp; TrySpin (Self) &gt; <span class="number">0</span>) <span class="keyword">break</span> ;</span><br><span class="line">&gt; </span><br><span class="line">&gt;         <span class="comment">// We can find that we were unpark()ed and redesignated _succ while</span></span><br><span class="line">&gt;         <span class="comment">// we were spinning.  That's harmless.  If we iterate and call park(),</span></span><br><span class="line">&gt;         <span class="comment">// park() will consume the event and return immediately and we'll</span></span><br><span class="line">&gt;         <span class="comment">// just spin again.  This pattern can repeat, leaving _succ to simply</span></span><br><span class="line">&gt;         <span class="comment">// spin on a CPU.  Enable Knob_ResetEvent to clear pending unparks().</span></span><br><span class="line">&gt;         <span class="comment">// Alternately, we can sample fired() here, and if set, forgo spinning</span></span><br><span class="line">&gt;         <span class="comment">// in the next iteration.</span></span><br><span class="line">&gt; </span><br><span class="line">&gt;         <span class="keyword">if</span> ((Knob_ResetEvent &amp; <span class="number">1</span>) &amp;&amp; Self-&gt;_ParkEvent-&gt;fired()) &#123;</span><br><span class="line">&gt;            Self-&gt;_ParkEvent-&gt;reset() ;</span><br><span class="line">&gt;            OrderAccess::fence() ;</span><br><span class="line">&gt;         &#125;</span><br><span class="line">&gt;         <span class="keyword">if</span> (_succ == Self) _succ = <span class="literal">NULL</span> ;</span><br><span class="line">&gt; </span><br><span class="line">&gt;         <span class="comment">// Invariant: after clearing _succ a thread *must* retry _owner before parking.</span></span><br><span class="line">&gt;         OrderAccess::fence() ;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt;     <span class="comment">// Egress :</span></span><br><span class="line">&gt;     <span class="comment">// Self has acquired the lock -- Unlink Self from the cxq or EntryList.</span></span><br><span class="line">&gt;     <span class="comment">// Normally we'll find Self on the EntryList .</span></span><br><span class="line">&gt;     <span class="comment">// From the perspective of the lock owner (this thread), the</span></span><br><span class="line">&gt;     <span class="comment">// EntryList is stable and cxq is prepend-only.</span></span><br><span class="line">&gt;     <span class="comment">// The head of cxq is volatile but the interior is stable.</span></span><br><span class="line">&gt;     <span class="comment">// In addition, Self.TState is stable.</span></span><br><span class="line">&gt; </span><br><span class="line">&gt;     assert (_owner == Self      , <span class="string">"invariant"</span>) ;</span><br><span class="line">&gt;     assert (object() != <span class="literal">NULL</span>    , <span class="string">"invariant"</span>) ;</span><br><span class="line">&gt;     <span class="comment">// I'd like to write:</span></span><br><span class="line">&gt;     <span class="comment">//   guarantee (((oop)(object()))-&gt;mark() == markOopDesc::encode(this), "invariant") ;</span></span><br><span class="line">&gt;     <span class="comment">// but as we're at a safepoint that's not safe.</span></span><br><span class="line">&gt; </span><br><span class="line">&gt;     UnlinkAfterAcquire (Self, &amp;node) ;</span><br><span class="line">&gt;     <span class="keyword">if</span> (_succ == Self) _succ = <span class="literal">NULL</span> ;</span><br><span class="line">&gt; </span><br><span class="line">&gt;     assert (_succ != Self, <span class="string">"invariant"</span>) ;</span><br><span class="line">&gt;     <span class="keyword">if</span> (_Responsible == Self) &#123;</span><br><span class="line">&gt;         _Responsible = <span class="literal">NULL</span> ;</span><br><span class="line">&gt;         OrderAccess::fence(); <span class="comment">// Dekker pivot-point</span></span><br><span class="line">&gt; </span><br><span class="line">&gt;         <span class="comment">// We may leave threads on cxq|EntryList without a designated</span></span><br><span class="line">&gt;         <span class="comment">// "Responsible" thread.  This is benign.  When this thread subsequently</span></span><br><span class="line">&gt;         <span class="comment">// exits the monitor it can "see" such preexisting "old" threads --</span></span><br><span class="line">&gt;         <span class="comment">// threads that arrived on the cxq|EntryList before the fence, above --</span></span><br><span class="line">&gt;         <span class="comment">// by LDing cxq|EntryList.  Newly arrived threads -- that is, threads</span></span><br><span class="line">&gt;         <span class="comment">// that arrive on cxq after the ST:MEMBAR, above -- will set Responsible</span></span><br><span class="line">&gt;         <span class="comment">// non-null and elect a new "Responsible" timer thread.</span></span><br><span class="line">&gt;         <span class="comment">//</span></span><br><span class="line">&gt;         <span class="comment">// This thread executes:</span></span><br><span class="line">&gt;         <span class="comment">//    ST Responsible=null; MEMBAR    (in enter epilog - here)</span></span><br><span class="line">&gt;         <span class="comment">//    LD cxq|EntryList               (in subsequent exit)</span></span><br><span class="line">&gt;         <span class="comment">//</span></span><br><span class="line">&gt;         <span class="comment">// Entering threads in the slow/contended path execute:</span></span><br><span class="line">&gt;         <span class="comment">//    ST cxq=nonnull; MEMBAR; LD Responsible (in enter prolog)</span></span><br><span class="line">&gt;         <span class="comment">//    The (ST cxq; MEMBAR) is accomplished with CAS().</span></span><br><span class="line">&gt;         <span class="comment">//</span></span><br><span class="line">&gt;         <span class="comment">// The MEMBAR, above, prevents the LD of cxq|EntryList in the subsequent</span></span><br><span class="line">&gt;         <span class="comment">// exit operation from floating above the ST Responsible=null.</span></span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt;     <span class="comment">// We've acquired ownership with CAS().</span></span><br><span class="line">&gt;     <span class="comment">// CAS is serializing -- it has MEMBAR/FENCE-equivalent semantics.</span></span><br><span class="line">&gt;     <span class="comment">// But since the CAS() this thread may have also stored into _succ,</span></span><br><span class="line">&gt;     <span class="comment">// EntryList, cxq or Responsible.  These meta-data updates must be</span></span><br><span class="line">&gt;     <span class="comment">// visible __before this thread subsequently drops the lock.</span></span><br><span class="line">&gt;     <span class="comment">// Consider what could occur if we didn't enforce this constraint --</span></span><br><span class="line">&gt;     <span class="comment">// STs to monitor meta-data and user-data could reorder with (become</span></span><br><span class="line">&gt;     <span class="comment">// visible after) the ST in exit that drops ownership of the lock.</span></span><br><span class="line">&gt;     <span class="comment">// Some other thread could then acquire the lock, but observe inconsistent</span></span><br><span class="line">&gt;     <span class="comment">// or old monitor meta-data and heap data.  That violates the JMM.</span></span><br><span class="line">&gt;     <span class="comment">// To that end, the 1-0 exit() operation must have at least STST|LDST</span></span><br><span class="line">&gt;     <span class="comment">// "release" barrier semantics.  Specifically, there must be at least a</span></span><br><span class="line">&gt;     <span class="comment">// STST|LDST barrier in exit() before the ST of null into _owner that drops</span></span><br><span class="line">&gt;     <span class="comment">// the lock.   The barrier ensures that changes to monitor meta-data and data</span></span><br><span class="line">&gt;     <span class="comment">// protected by the lock will be visible before we release the lock, and</span></span><br><span class="line">&gt;     <span class="comment">// therefore before some other thread (CPU) has a chance to acquire the lock.</span></span><br><span class="line">&gt;     <span class="comment">// See also: http://gee.cs.oswego.edu/dl/jmm/cookbook.html.</span></span><br><span class="line">&gt;     <span class="comment">//</span></span><br><span class="line">&gt;     <span class="comment">// Critically, any prior STs to _succ or EntryList must be visible before</span></span><br><span class="line">&gt;     <span class="comment">// the ST of null into _owner in the *subsequent* (following) corresponding</span></span><br><span class="line">&gt;     <span class="comment">// monitorexit.  Recall too, that in 1-0 mode monitorexit does not necessarily</span></span><br><span class="line">&gt;     <span class="comment">// execute a serializing instruction.</span></span><br><span class="line">&gt; </span><br><span class="line">&gt;     <span class="keyword">if</span> (SyncFlags &amp; <span class="number">8</span>) &#123;</span><br><span class="line">&gt;        OrderAccess::fence() ;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt;     <span class="keyword">return</span> ;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<ol>
<li><p>先尝试用cas锁</p>
</li>
<li><p>在spin一轮，看能不能获得锁</p>
</li>
<li><p>没办法了，只能创建一个ObjectWaiter node(Self)</p>
</li>
<li><p>把这个waiter node push到cxq的头部，cxq是LL of recently-arrived threads blocked on entry</p>
</li>
<li><p>cas 失败，说明头变了，立马cas try lock一次</p>
</li>
<li><p>如果nxt，_EntryList都是空的，把当前thread设置为这个monitor的_Responsible thread</p>
</li>
<li><p>死循环</p>
<blockquote>
<ol>
<li>如果cas获得锁成功，退出</li>
<li>如果这个线程是当前的Responsible thread，park 1 ms，否则 一直park，等别人来唤醒</li>
<li>唤醒后，检查cas能否成功</li>
</ol>
</blockquote>
</li>
<li><p>清理ObjectWaiter</p>
</li>
</ol>
</blockquote>
<h3 id="MonitorExit"><a href="#MonitorExit" class="headerlink" title="MonitorExit"></a>MonitorExit</h3><blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&gt; IRT_ENTRY_NO_ASYNC(<span class="keyword">void</span>, InterpreterRuntime::monitorexit(JavaThread* thread, BasicObjectLock* elem))</span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">ifdef</span> ASSERT</span></span><br><span class="line">&gt;   thread-&gt;last_frame().interpreter_frame_verify_monitor(elem);</span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&gt;   <span class="function">Handle <span class="title">h_obj</span><span class="params">(thread, elem-&gt;obj())</span></span>;</span><br><span class="line">&gt;   assert(Universe::heap()-&gt;is_in_reserved_or_null(h_obj()),</span><br><span class="line">&gt;          <span class="string">"must be NULL or an object"</span>);</span><br><span class="line">&gt;   <span class="keyword">if</span> (elem == <span class="literal">NULL</span> || h_obj()-&gt;is_unlocked()) &#123;</span><br><span class="line">&gt;     THROW(vmSymbols::java_lang_IllegalMonitorStateException());</span><br><span class="line">&gt;   &#125;</span><br><span class="line">&gt;   ObjectSynchronizer::slow_exit(h_obj(), elem-&gt;lock(), thread);</span><br><span class="line">&gt;   <span class="comment">// Free entry. This must be done here, since a pending exception might be installed on</span></span><br><span class="line">&gt;   <span class="comment">// exit. If it is not cleared, the exception handling code will try to unlock the monitor again.</span></span><br><span class="line">&gt;   elem-&gt;set_obj(<span class="literal">NULL</span>);</span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">ifdef</span> ASSERT</span></span><br><span class="line">&gt;   thread-&gt;last_frame().interpreter_frame_verify_monitor(elem);</span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&gt; IRT_END</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
</blockquote>
<h3 id="slow-exit"><a href="#slow-exit" class="headerlink" title="slow_exit"></a>slow_exit</h3><blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">void</span> ObjectSynchronizer::fast_exit(oop object, BasicLock* lock, TRAPS) &#123;</span><br><span class="line">&gt;   assert(!object-&gt;mark()-&gt;has_bias_pattern(), <span class="string">"should not see bias pattern here"</span>);</span><br><span class="line">&gt;   <span class="comment">// if displaced header is null, the previous enter is recursive enter, no-op</span></span><br><span class="line">&gt;   markOop dhw = lock-&gt;displaced_header();</span><br><span class="line">&gt;   markOop mark ;</span><br><span class="line">&gt;   <span class="keyword">if</span> (dhw == <span class="literal">NULL</span>) &#123;</span><br><span class="line">&gt;      <span class="comment">// Recursive stack-lock.</span></span><br><span class="line">&gt;      <span class="comment">// Diagnostics -- Could be: stack-locked, inflating, inflated.</span></span><br><span class="line">&gt;      mark = object-&gt;mark() ;</span><br><span class="line">&gt;      assert (!mark-&gt;is_neutral(), <span class="string">"invariant"</span>) ;</span><br><span class="line">&gt;      <span class="keyword">if</span> (mark-&gt;has_locker() &amp;&amp; mark != markOopDesc::INFLATING()) &#123;</span><br><span class="line">&gt;         assert(THREAD-&gt;is_lock_owned((address)mark-&gt;locker()), <span class="string">"invariant"</span>) ;</span><br><span class="line">&gt;      &#125;</span><br><span class="line">&gt;      <span class="keyword">if</span> (mark-&gt;has_monitor()) &#123;</span><br><span class="line">&gt;         ObjectMonitor * m = mark-&gt;monitor() ;</span><br><span class="line">&gt;         assert(((oop)(m-&gt;object()))-&gt;mark() == mark, <span class="string">"invariant"</span>) ;</span><br><span class="line">&gt;         assert(m-&gt;is_entered(THREAD), <span class="string">"invariant"</span>) ;</span><br><span class="line">&gt;      &#125;</span><br><span class="line">&gt;      <span class="keyword">return</span> ;</span><br><span class="line">&gt;   &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt;   mark = object-&gt;mark() ;</span><br><span class="line">&gt; </span><br><span class="line">&gt;   <span class="comment">// If the object is stack-locked by the current thread, try to</span></span><br><span class="line">&gt;   <span class="comment">// swing the displaced header from the box back to the mark.</span></span><br><span class="line">&gt;   <span class="keyword">if</span> (mark == (markOop) lock) &#123;</span><br><span class="line">&gt;      assert (dhw-&gt;is_neutral(), <span class="string">"invariant"</span>) ;</span><br><span class="line">&gt;      <span class="keyword">if</span> ((markOop) Atomic::cmpxchg_ptr (dhw, object-&gt;mark_addr(), mark) == mark) &#123;</span><br><span class="line">&gt;         TEVENT (fast_exit: release stacklock) ;</span><br><span class="line">&gt;         <span class="keyword">return</span>;</span><br><span class="line">&gt;      &#125;</span><br><span class="line">&gt;   &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt;   ObjectSynchronizer::inflate(THREAD, object)-&gt;<span class="built_in">exit</span> (<span class="literal">true</span>, THREAD) ;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<ol>
<li>如果displace_header为null，说明是重入锁</li>
<li>如果是stack-locked，cas 解锁</li>
<li>exit</li>
</ol>
</blockquote>
<h3 id="ObjectMonitor-exit"><a href="#ObjectMonitor-exit" class="headerlink" title="ObjectMonitor::exit"></a>ObjectMonitor::exit</h3><blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">void</span> ATTR ObjectMonitor::<span class="built_in">exit</span>(<span class="keyword">bool</span> not_suspended, TRAPS) &#123;</span><br><span class="line">&gt;    Thread * Self = THREAD ;</span><br><span class="line">&gt;    <span class="keyword">if</span> (THREAD != _owner) &#123;</span><br><span class="line">&gt;      <span class="keyword">if</span> (THREAD-&gt;is_lock_owned((address) _owner)) &#123;</span><br><span class="line">&gt;        <span class="comment">// Transmute _owner from a BasicLock pointer to a Thread address.</span></span><br><span class="line">&gt;        <span class="comment">// We don't need to hold _mutex for this transition.</span></span><br><span class="line">&gt;        <span class="comment">// Non-null to Non-null is safe as long as all readers can</span></span><br><span class="line">&gt;        <span class="comment">// tolerate either flavor.</span></span><br><span class="line">&gt;        assert (_recursions == <span class="number">0</span>, <span class="string">"invariant"</span>) ;</span><br><span class="line">&gt;        _owner = THREAD ;</span><br><span class="line">&gt;        _recursions = <span class="number">0</span> ;</span><br><span class="line">&gt;        OwnerIsThread = <span class="number">1</span> ;</span><br><span class="line">&gt;      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">&gt;        <span class="comment">// <span class="doctag">NOTE:</span> we need to handle unbalanced monitor enter/exit</span></span><br><span class="line">&gt;        <span class="comment">// in native code by throwing an exception.</span></span><br><span class="line">&gt;        <span class="comment">// <span class="doctag">TODO:</span> Throw an IllegalMonitorStateException ?</span></span><br><span class="line">&gt;        TEVENT (Exit - Throw IMSX) ;</span><br><span class="line">&gt;        assert(<span class="literal">false</span>, <span class="string">"Non-balanced monitor enter/exit!"</span>);</span><br><span class="line">&gt;        <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">&gt;           THROW(vmSymbols::java_lang_IllegalMonitorStateException());</span><br><span class="line">&gt;        &#125;</span><br><span class="line">&gt;        <span class="keyword">return</span>;</span><br><span class="line">&gt;      &#125;</span><br><span class="line">&gt;    &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt;    <span class="keyword">if</span> (_recursions != <span class="number">0</span>) &#123;</span><br><span class="line">&gt;      _recursions--;        <span class="comment">// this is simple recursive enter</span></span><br><span class="line">&gt;      TEVENT (Inflated <span class="built_in">exit</span> - recursive) ;</span><br><span class="line">&gt;      <span class="keyword">return</span> ;</span><br><span class="line">&gt;    &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt;    <span class="comment">// Invariant: after setting Responsible=null an thread must execute</span></span><br><span class="line">&gt;    <span class="comment">// a MEMBAR or other serializing instruction before fetching EntryList|cxq.</span></span><br><span class="line">&gt;    <span class="keyword">if</span> ((SyncFlags &amp; <span class="number">4</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">&gt;       _Responsible = <span class="literal">NULL</span> ;</span><br><span class="line">&gt;    &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">if</span> INCLUDE_TRACE</span></span><br><span class="line">&gt;    <span class="comment">// get the owner's thread id for the MonitorEnter event</span></span><br><span class="line">&gt;    <span class="comment">// if it is enabled and the thread isn't suspended</span></span><br><span class="line">&gt;    <span class="keyword">if</span> (not_suspended &amp;&amp; Tracing::is_event_enabled(TraceJavaMonitorEnterEvent)) &#123;</span><br><span class="line">&gt;      _previous_owner_tid = SharedRuntime::get_java_tid(Self);</span><br><span class="line">&gt;    &#125;</span><br><span class="line">&gt; <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&gt; </span><br><span class="line">&gt;    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">&gt;       assert (THREAD == _owner, <span class="string">"invariant"</span>) ;</span><br><span class="line">&gt; </span><br><span class="line">&gt; </span><br><span class="line">&gt;       <span class="keyword">if</span> (Knob_ExitPolicy == <span class="number">0</span>) &#123;</span><br><span class="line">&gt;          <span class="comment">// release semantics: prior loads and stores from within the critical section</span></span><br><span class="line">&gt;          <span class="comment">// must not float (reorder) past the following store that drops the lock.</span></span><br><span class="line">&gt;          <span class="comment">// On SPARC that requires MEMBAR #loadstore|#storestore.</span></span><br><span class="line">&gt;          <span class="comment">// But of course in TSO #loadstore|#storestore is not required.</span></span><br><span class="line">&gt;          <span class="comment">// I'd like to write one of the following:</span></span><br><span class="line">&gt;          <span class="comment">// A.  OrderAccess::release() ; _owner = NULL</span></span><br><span class="line">&gt;          <span class="comment">// B.  OrderAccess::loadstore(); OrderAccess::storestore(); _owner = NULL;</span></span><br><span class="line">&gt;          <span class="comment">// Unfortunately OrderAccess::release() and OrderAccess::loadstore() both</span></span><br><span class="line">&gt;          <span class="comment">// store into a _dummy variable.  That store is not needed, but can result</span></span><br><span class="line">&gt;          <span class="comment">// in massive wasteful coherency traffic on classic SMP systems.</span></span><br><span class="line">&gt;          <span class="comment">// Instead, I use release_store(), which is implemented as just a simple</span></span><br><span class="line">&gt;          <span class="comment">// ST on x64, x86 and SPARC.</span></span><br><span class="line">&gt;          OrderAccess::release_store_ptr (&amp;_owner, <span class="literal">NULL</span>) ;   <span class="comment">// drop the lock</span></span><br><span class="line">&gt;          OrderAccess::storeload() ;                         <span class="comment">// See if we need to wake a successor</span></span><br><span class="line">&gt;          <span class="keyword">if</span> ((<span class="keyword">intptr_t</span>(_EntryList)|<span class="keyword">intptr_t</span>(_cxq)) == <span class="number">0</span> || _succ != <span class="literal">NULL</span>) &#123;</span><br><span class="line">&gt;             TEVENT (Inflated <span class="built_in">exit</span> - simple egress) ;</span><br><span class="line">&gt;             <span class="keyword">return</span> ;</span><br><span class="line">&gt;          &#125;</span><br><span class="line">&gt;          TEVENT (Inflated <span class="built_in">exit</span> - <span class="keyword">complex</span> egress) ;</span><br><span class="line">&gt; </span><br><span class="line">&gt;          <span class="comment">// Normally the exiting thread is responsible for ensuring succession,</span></span><br><span class="line">&gt;          <span class="comment">// but if other successors are ready or other entering threads are spinning</span></span><br><span class="line">&gt;          <span class="comment">// then this thread can simply store NULL into _owner and exit without</span></span><br><span class="line">&gt;          <span class="comment">// waking a successor.  The existence of spinners or ready successors</span></span><br><span class="line">&gt;          <span class="comment">// guarantees proper succession (liveness).  Responsibility passes to the</span></span><br><span class="line">&gt;          <span class="comment">// ready or running successors.  The exiting thread delegates the duty.</span></span><br><span class="line">&gt;          <span class="comment">// More precisely, if a successor already exists this thread is absolved</span></span><br><span class="line">&gt;          <span class="comment">// of the responsibility of waking (unparking) one.</span></span><br><span class="line">&gt;          <span class="comment">//</span></span><br><span class="line">&gt;          <span class="comment">// The _succ variable is critical to reducing futile wakeup frequency.</span></span><br><span class="line">&gt;          <span class="comment">// _succ identifies the "heir presumptive" thread that has been made</span></span><br><span class="line">&gt;          <span class="comment">// ready (unparked) but that has not yet run.  We need only one such</span></span><br><span class="line">&gt;          <span class="comment">// successor thread to guarantee progress.</span></span><br><span class="line">&gt;          <span class="comment">// See http://www.usenix.org/events/jvm01/full_papers/dice/dice.pdf</span></span><br><span class="line">&gt;          <span class="comment">// section 3.3 "Futile Wakeup Throttling" for details.</span></span><br><span class="line">&gt;          <span class="comment">//</span></span><br><span class="line">&gt;          <span class="comment">// Note that spinners in Enter() also set _succ non-null.</span></span><br><span class="line">&gt;          <span class="comment">// In the current implementation spinners opportunistically set</span></span><br><span class="line">&gt;          <span class="comment">// _succ so that exiting threads might avoid waking a successor.</span></span><br><span class="line">&gt;          <span class="comment">// Another less appealing alternative would be for the exiting thread</span></span><br><span class="line">&gt;          <span class="comment">// to drop the lock and then spin briefly to see if a spinner managed</span></span><br><span class="line">&gt;          <span class="comment">// to acquire the lock.  If so, the exiting thread could exit</span></span><br><span class="line">&gt;          <span class="comment">// immediately without waking a successor, otherwise the exiting</span></span><br><span class="line">&gt;          <span class="comment">// thread would need to dequeue and wake a successor.</span></span><br><span class="line">&gt;          <span class="comment">// (Note that we'd need to make the post-drop spin short, but no</span></span><br><span class="line">&gt;          <span class="comment">// shorter than the worst-case round-trip cache-line migration time.</span></span><br><span class="line">&gt;          <span class="comment">// The dropped lock needs to become visible to the spinner, and then</span></span><br><span class="line">&gt;          <span class="comment">// the acquisition of the lock by the spinner must become visible to</span></span><br><span class="line">&gt;          <span class="comment">// the exiting thread).</span></span><br><span class="line">&gt;          <span class="comment">//</span></span><br><span class="line">&gt; </span><br><span class="line">&gt;          <span class="comment">// It appears that an heir-presumptive (successor) must be made ready.</span></span><br><span class="line">&gt;          <span class="comment">// Only the current lock owner can manipulate the EntryList or</span></span><br><span class="line">&gt;          <span class="comment">// drain _cxq, so we need to reacquire the lock.  If we fail</span></span><br><span class="line">&gt;          <span class="comment">// to reacquire the lock the responsibility for ensuring succession</span></span><br><span class="line">&gt;          <span class="comment">// falls to the new owner.</span></span><br><span class="line">&gt;          <span class="comment">//</span></span><br><span class="line">&gt;          <span class="keyword">if</span> (Atomic::cmpxchg_ptr (THREAD, &amp;_owner, <span class="literal">NULL</span>) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">&gt;             <span class="keyword">return</span> ;</span><br><span class="line">&gt;          &#125;</span><br><span class="line">&gt;          TEVENT (Exit - Reacquired) ;</span><br><span class="line">&gt;       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">&gt;          <span class="keyword">if</span> ((<span class="keyword">intptr_t</span>(_EntryList)|<span class="keyword">intptr_t</span>(_cxq)) == <span class="number">0</span> || _succ != <span class="literal">NULL</span>) &#123;</span><br><span class="line">&gt;             OrderAccess::release_store_ptr (&amp;_owner, <span class="literal">NULL</span>) ;   <span class="comment">// drop the lock</span></span><br><span class="line">&gt;             OrderAccess::storeload() ;</span><br><span class="line">&gt;             <span class="comment">// Ratify the previously observed values.</span></span><br><span class="line">&gt;             <span class="keyword">if</span> (_cxq == <span class="literal">NULL</span> || _succ != <span class="literal">NULL</span>) &#123;</span><br><span class="line">&gt;                 TEVENT (Inflated <span class="built_in">exit</span> - simple egress) ;</span><br><span class="line">&gt;                 <span class="keyword">return</span> ;</span><br><span class="line">&gt;             &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt;             <span class="comment">// inopportune interleaving -- the exiting thread (this thread)</span></span><br><span class="line">&gt;             <span class="comment">// in the fast-exit path raced an entering thread in the slow-enter</span></span><br><span class="line">&gt;             <span class="comment">// path.</span></span><br><span class="line">&gt;             <span class="comment">// We have two choices:</span></span><br><span class="line">&gt;             <span class="comment">// A.  Try to reacquire the lock.</span></span><br><span class="line">&gt;             <span class="comment">//     If the CAS() fails return immediately, otherwise</span></span><br><span class="line">&gt;             <span class="comment">//     we either restart/rerun the exit operation, or simply</span></span><br><span class="line">&gt;             <span class="comment">//     fall-through into the code below which wakes a successor.</span></span><br><span class="line">&gt;             <span class="comment">// B.  If the elements forming the EntryList|cxq are TSM</span></span><br><span class="line">&gt;             <span class="comment">//     we could simply unpark() the lead thread and return</span></span><br><span class="line">&gt;             <span class="comment">//     without having set _succ.</span></span><br><span class="line">&gt;             <span class="keyword">if</span> (Atomic::cmpxchg_ptr (THREAD, &amp;_owner, <span class="literal">NULL</span>) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">&gt;                TEVENT (Inflated <span class="built_in">exit</span> - reacquired succeeded) ;</span><br><span class="line">&gt;                <span class="keyword">return</span> ;</span><br><span class="line">&gt;             &#125;</span><br><span class="line">&gt;             TEVENT (Inflated <span class="built_in">exit</span> - reacquired failed) ;</span><br><span class="line">&gt;          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">&gt;             TEVENT (Inflated <span class="built_in">exit</span> - <span class="keyword">complex</span> egress) ;</span><br><span class="line">&gt;          &#125;</span><br><span class="line">&gt;       &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt;       guarantee (_owner == THREAD, <span class="string">"invariant"</span>) ;</span><br><span class="line">&gt; </span><br><span class="line">&gt;       ObjectWaiter * w = <span class="literal">NULL</span> ;</span><br><span class="line">&gt;       <span class="keyword">int</span> QMode = Knob_QMode ;</span><br><span class="line">&gt; </span><br><span class="line">&gt;       <span class="keyword">if</span> (QMode == <span class="number">2</span> &amp;&amp; _cxq != <span class="literal">NULL</span>) &#123;</span><br><span class="line">&gt;           <span class="comment">// QMode == 2 : cxq has precedence over EntryList.</span></span><br><span class="line">&gt;           <span class="comment">// Try to directly wake a successor from the cxq.</span></span><br><span class="line">&gt;           <span class="comment">// If successful, the successor will need to unlink itself from cxq.</span></span><br><span class="line">&gt;           w = _cxq ;</span><br><span class="line">&gt;           assert (w != <span class="literal">NULL</span>, <span class="string">"invariant"</span>) ;</span><br><span class="line">&gt;           assert (w-&gt;TState == ObjectWaiter::TS_CXQ, <span class="string">"Invariant"</span>) ;</span><br><span class="line">&gt;           ExitEpilog (Self, w) ;</span><br><span class="line">&gt;           <span class="keyword">return</span> ;</span><br><span class="line">&gt;       &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt;       <span class="keyword">if</span> (QMode == <span class="number">3</span> &amp;&amp; _cxq != <span class="literal">NULL</span>) &#123;</span><br><span class="line">&gt;           <span class="comment">// Aggressively drain cxq into EntryList at the first opportunity.</span></span><br><span class="line">&gt;           <span class="comment">// This policy ensure that recently-run threads live at the head of EntryList.</span></span><br><span class="line">&gt;           <span class="comment">// Drain _cxq into EntryList - bulk transfer.</span></span><br><span class="line">&gt;           <span class="comment">// First, detach _cxq.</span></span><br><span class="line">&gt;           <span class="comment">// The following loop is tantamount to: w = swap (&amp;cxq, NULL)</span></span><br><span class="line">&gt;           w = _cxq ;</span><br><span class="line">&gt;           <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">&gt;              assert (w != <span class="literal">NULL</span>, <span class="string">"Invariant"</span>) ;</span><br><span class="line">&gt;              ObjectWaiter * u = (ObjectWaiter *) Atomic::cmpxchg_ptr (<span class="literal">NULL</span>, &amp;_cxq, w) ;</span><br><span class="line">&gt;              <span class="keyword">if</span> (u == w) <span class="keyword">break</span> ;</span><br><span class="line">&gt;              w = u ;</span><br><span class="line">&gt;           &#125;</span><br><span class="line">&gt;           assert (w != <span class="literal">NULL</span>              , <span class="string">"invariant"</span>) ;</span><br><span class="line">&gt; </span><br><span class="line">&gt;           ObjectWaiter * q = <span class="literal">NULL</span> ;</span><br><span class="line">&gt;           ObjectWaiter * p ;</span><br><span class="line">&gt;           <span class="keyword">for</span> (p = w ; p != <span class="literal">NULL</span> ; p = p-&gt;_next) &#123;</span><br><span class="line">&gt;               guarantee (p-&gt;TState == ObjectWaiter::TS_CXQ, <span class="string">"Invariant"</span>) ;</span><br><span class="line">&gt;               p-&gt;TState = ObjectWaiter::TS_ENTER ;</span><br><span class="line">&gt;               p-&gt;_prev = q ;</span><br><span class="line">&gt;               q = p ;</span><br><span class="line">&gt;           &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt;           <span class="comment">// Append the RATs to the EntryList</span></span><br><span class="line">&gt;           <span class="comment">// <span class="doctag">TODO:</span> organize EntryList as a CDLL so we can locate the tail in constant-time.</span></span><br><span class="line">&gt;           ObjectWaiter * Tail ;</span><br><span class="line">&gt;           <span class="keyword">for</span> (Tail = _EntryList ; Tail != <span class="literal">NULL</span> &amp;&amp; Tail-&gt;_next != <span class="literal">NULL</span> ; Tail = Tail-&gt;_next) ;</span><br><span class="line">&gt;           <span class="keyword">if</span> (Tail == <span class="literal">NULL</span>) &#123;</span><br><span class="line">&gt;               _EntryList = w ;</span><br><span class="line">&gt;           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">&gt;               Tail-&gt;_next = w ;</span><br><span class="line">&gt;               w-&gt;_prev = Tail ;</span><br><span class="line">&gt;           &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt;           <span class="comment">// Fall thru into code that tries to wake a successor from EntryList</span></span><br><span class="line">&gt;       &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt;       <span class="keyword">if</span> (QMode == <span class="number">4</span> &amp;&amp; _cxq != <span class="literal">NULL</span>) &#123;</span><br><span class="line">&gt;           <span class="comment">// Aggressively drain cxq into EntryList at the first opportunity.</span></span><br><span class="line">&gt;           <span class="comment">// This policy ensure that recently-run threads live at the head of EntryList.</span></span><br><span class="line">&gt; </span><br><span class="line">&gt;           <span class="comment">// Drain _cxq into EntryList - bulk transfer.</span></span><br><span class="line">&gt;           <span class="comment">// First, detach _cxq.</span></span><br><span class="line">&gt;           <span class="comment">// The following loop is tantamount to: w = swap (&amp;cxq, NULL)</span></span><br><span class="line">&gt;           w = _cxq ;</span><br><span class="line">&gt;           <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">&gt;              assert (w != <span class="literal">NULL</span>, <span class="string">"Invariant"</span>) ;</span><br><span class="line">&gt;              ObjectWaiter * u = (ObjectWaiter *) Atomic::cmpxchg_ptr (<span class="literal">NULL</span>, &amp;_cxq, w) ;</span><br><span class="line">&gt;              <span class="keyword">if</span> (u == w) <span class="keyword">break</span> ;</span><br><span class="line">&gt;              w = u ;</span><br><span class="line">&gt;           &#125;</span><br><span class="line">&gt;           assert (w != <span class="literal">NULL</span>              , <span class="string">"invariant"</span>) ;</span><br><span class="line">&gt; </span><br><span class="line">&gt;           ObjectWaiter * q = <span class="literal">NULL</span> ;</span><br><span class="line">&gt;           ObjectWaiter * p ;</span><br><span class="line">&gt;           <span class="keyword">for</span> (p = w ; p != <span class="literal">NULL</span> ; p = p-&gt;_next) &#123;</span><br><span class="line">&gt;               guarantee (p-&gt;TState == ObjectWaiter::TS_CXQ, <span class="string">"Invariant"</span>) ;</span><br><span class="line">&gt;               p-&gt;TState = ObjectWaiter::TS_ENTER ;</span><br><span class="line">&gt;               p-&gt;_prev = q ;</span><br><span class="line">&gt;               q = p ;</span><br><span class="line">&gt;           &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt;           <span class="comment">// Prepend the RATs to the EntryList</span></span><br><span class="line">&gt;           <span class="keyword">if</span> (_EntryList != <span class="literal">NULL</span>) &#123;</span><br><span class="line">&gt;               q-&gt;_next = _EntryList ;</span><br><span class="line">&gt;               _EntryList-&gt;_prev = q ;</span><br><span class="line">&gt;           &#125;</span><br><span class="line">&gt;           _EntryList = w ;</span><br><span class="line">&gt; </span><br><span class="line">&gt;           <span class="comment">// Fall thru into code that tries to wake a successor from EntryList</span></span><br><span class="line">&gt;       &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt;       w = _EntryList  ;</span><br><span class="line">&gt;       <span class="keyword">if</span> (w != <span class="literal">NULL</span>) &#123;</span><br><span class="line">&gt;           <span class="comment">// I'd like to write: guarantee (w-&gt;_thread != Self).</span></span><br><span class="line">&gt;           <span class="comment">// But in practice an exiting thread may find itself on the EntryList.</span></span><br><span class="line">&gt;           <span class="comment">// Lets say thread T1 calls O.wait().  Wait() enqueues T1 on O's waitset and</span></span><br><span class="line">&gt;           <span class="comment">// then calls exit().  Exit release the lock by setting O._owner to NULL.</span></span><br><span class="line">&gt;           <span class="comment">// Lets say T1 then stalls.  T2 acquires O and calls O.notify().  The</span></span><br><span class="line">&gt;           <span class="comment">// notify() operation moves T1 from O's waitset to O's EntryList. T2 then</span></span><br><span class="line">&gt;           <span class="comment">// release the lock "O".  T2 resumes immediately after the ST of null into</span></span><br><span class="line">&gt;           <span class="comment">// _owner, above.  T2 notices that the EntryList is populated, so it</span></span><br><span class="line">&gt;           <span class="comment">// reacquires the lock and then finds itself on the EntryList.</span></span><br><span class="line">&gt;           <span class="comment">// Given all that, we have to tolerate the circumstance where "w" is</span></span><br><span class="line">&gt;           <span class="comment">// associated with Self.</span></span><br><span class="line">&gt;           assert (w-&gt;TState == ObjectWaiter::TS_ENTER, <span class="string">"invariant"</span>) ;</span><br><span class="line">&gt;           ExitEpilog (Self, w) ;</span><br><span class="line">&gt;           <span class="keyword">return</span> ;</span><br><span class="line">&gt;       &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt;       <span class="comment">// If we find that both _cxq and EntryList are null then just</span></span><br><span class="line">&gt;       <span class="comment">// re-run the exit protocol from the top.</span></span><br><span class="line">&gt;       w = _cxq ;</span><br><span class="line">&gt;       <span class="keyword">if</span> (w == <span class="literal">NULL</span>) <span class="keyword">continue</span> ;</span><br><span class="line">&gt; </span><br><span class="line">&gt;       <span class="comment">// Drain _cxq into EntryList - bulk transfer.</span></span><br><span class="line">&gt;       <span class="comment">// First, detach _cxq.</span></span><br><span class="line">&gt;       <span class="comment">// The following loop is tantamount to: w = swap (&amp;cxq, NULL)</span></span><br><span class="line">&gt;       <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">&gt;           assert (w != <span class="literal">NULL</span>, <span class="string">"Invariant"</span>) ;</span><br><span class="line">&gt;           ObjectWaiter * u = (ObjectWaiter *) Atomic::cmpxchg_ptr (<span class="literal">NULL</span>, &amp;_cxq, w) ;</span><br><span class="line">&gt;           <span class="keyword">if</span> (u == w) <span class="keyword">break</span> ;</span><br><span class="line">&gt;           w = u ;</span><br><span class="line">&gt;       &#125;</span><br><span class="line">&gt;       TEVENT (Inflated <span class="built_in">exit</span> - drain cxq into EntryList) ;</span><br><span class="line">&gt; </span><br><span class="line">&gt;       assert (w != <span class="literal">NULL</span>              , <span class="string">"invariant"</span>) ;</span><br><span class="line">&gt;       assert (_EntryList  == <span class="literal">NULL</span>    , <span class="string">"invariant"</span>) ;</span><br><span class="line">&gt; </span><br><span class="line">&gt;       <span class="comment">// Convert the LIFO SLL anchored by _cxq into a DLL.</span></span><br><span class="line">&gt;       <span class="comment">// The list reorganization step operates in O(LENGTH(w)) time.</span></span><br><span class="line">&gt;       <span class="comment">// It's critical that this step operate quickly as</span></span><br><span class="line">&gt;       <span class="comment">// "Self" still holds the outer-lock, restricting parallelism</span></span><br><span class="line">&gt;       <span class="comment">// and effectively lengthening the critical section.</span></span><br><span class="line">&gt;       <span class="comment">// Invariant: s chases t chases u.</span></span><br><span class="line">&gt;       <span class="comment">// TODO-<span class="doctag">FIXME:</span> consider changing EntryList from a DLL to a CDLL so</span></span><br><span class="line">&gt;       <span class="comment">// we have faster access to the tail.</span></span><br><span class="line">&gt; </span><br><span class="line">&gt;       <span class="keyword">if</span> (QMode == <span class="number">1</span>) &#123;</span><br><span class="line">&gt;          <span class="comment">// QMode == 1 : drain cxq to EntryList, reversing order</span></span><br><span class="line">&gt;          <span class="comment">// We also reverse the order of the list.</span></span><br><span class="line">&gt;          ObjectWaiter * s = <span class="literal">NULL</span> ;</span><br><span class="line">&gt;          ObjectWaiter * t = w ;</span><br><span class="line">&gt;          ObjectWaiter * u = <span class="literal">NULL</span> ;</span><br><span class="line">&gt;          <span class="keyword">while</span> (t != <span class="literal">NULL</span>) &#123;</span><br><span class="line">&gt;              guarantee (t-&gt;TState == ObjectWaiter::TS_CXQ, <span class="string">"invariant"</span>) ;</span><br><span class="line">&gt;              t-&gt;TState = ObjectWaiter::TS_ENTER ;</span><br><span class="line">&gt;              u = t-&gt;_next ;</span><br><span class="line">&gt;              t-&gt;_prev = u ;</span><br><span class="line">&gt;              t-&gt;_next = s ;</span><br><span class="line">&gt;              s = t;</span><br><span class="line">&gt;              t = u ;</span><br><span class="line">&gt;          &#125;</span><br><span class="line">&gt;          _EntryList  = s ;</span><br><span class="line">&gt;          assert (s != <span class="literal">NULL</span>, <span class="string">"invariant"</span>) ;</span><br><span class="line">&gt;       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">&gt;          <span class="comment">// QMode == 0 or QMode == 2</span></span><br><span class="line">&gt;          _EntryList = w ;</span><br><span class="line">&gt;          ObjectWaiter * q = <span class="literal">NULL</span> ;</span><br><span class="line">&gt;          ObjectWaiter * p ;</span><br><span class="line">&gt;          <span class="keyword">for</span> (p = w ; p != <span class="literal">NULL</span> ; p = p-&gt;_next) &#123;</span><br><span class="line">&gt;              guarantee (p-&gt;TState == ObjectWaiter::TS_CXQ, <span class="string">"Invariant"</span>) ;</span><br><span class="line">&gt;              p-&gt;TState = ObjectWaiter::TS_ENTER ;</span><br><span class="line">&gt;              p-&gt;_prev = q ;</span><br><span class="line">&gt;              q = p ;</span><br><span class="line">&gt;          &#125;</span><br><span class="line">&gt;       &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt;       <span class="comment">// In 1-0 mode we need: ST EntryList; MEMBAR #storestore; ST _owner = NULL</span></span><br><span class="line">&gt;       <span class="comment">// The MEMBAR is satisfied by the release_store() operation in ExitEpilog().</span></span><br><span class="line">&gt; </span><br><span class="line">&gt;       <span class="comment">// See if we can abdicate to a spinner instead of waking a thread.</span></span><br><span class="line">&gt;       <span class="comment">// A primary goal of the implementation is to reduce the</span></span><br><span class="line">&gt;       <span class="comment">// context-switch rate.</span></span><br><span class="line">&gt;       <span class="keyword">if</span> (_succ != <span class="literal">NULL</span>) <span class="keyword">continue</span>;</span><br><span class="line">&gt; </span><br><span class="line">&gt;       w = _EntryList  ;</span><br><span class="line">&gt;       <span class="keyword">if</span> (w != <span class="literal">NULL</span>) &#123;</span><br><span class="line">&gt;           guarantee (w-&gt;TState == ObjectWaiter::TS_ENTER, <span class="string">"invariant"</span>) ;</span><br><span class="line">&gt;           ExitEpilog (Self, w) ;</span><br><span class="line">&gt;           <span class="keyword">return</span> ;</span><br><span class="line">&gt;       &#125;</span><br><span class="line">&gt;    &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<ol>
<li>如果是重入锁，_recursions–</li>
<li>QMode == 2，目测是公平锁，取最近来的cxq，unpark</li>
<li>QMode == 3 ，先把cxq置为null，把从cxq取出来的waiter，连接在_EntryList后面</li>
<li>QMode == 4 ，先把cxq置为null，把从cxq取出来的waiter，连接在_EntryList前面</li>
<li>然后取出来_EntryList第一个元素，unpark</li>
<li>如果_EntryList为null，QMode == 1，reverse _EntryList 然后同理</li>
<li>总的来说，找一个waiter，把它unpark</li>
</ol>
</blockquote>

      
    </div>
</article>

    </li>
  
</ul>


            <footer>
    <div>© 2018 - fengjian </div>
    <div>
        <span>
            Powered by <a href="https://hexo.io">Hexo</a>
        </span>
        ,
        <span>
            Theme - <a href="https://github.com/nameoverflow/hexo-theme-icalm">Icalm</a>
        </span>
    </div>
</footer>

        </div>
    </div>
</div>
<script src="/js/pager/dist/singlepager.js"></script>
<script>
var sp = new Pager('data-pager-shell')

</script>
</body>
</html>